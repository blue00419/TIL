22.11.18
프로그래머스 합승 택시 요금
출발지 s, 목적지a,b를 각각 다익스트라로 모든 정점까지 최단거리를 구한다.
구해진 3개의 배열을가지고
한 정점에서 3곳까지 가는 거리의 합의 최소값을 구한다.
map[3][201]해서 s,a,b 3개의 정점에서 각 정점까지의 최단거리를 구했다.
answer에 엉청 큰값을 넣어둔뒤
answer = min(answer, map[0][각각의 정점] + map[1][각각의 정점] + map[2][각각의 정점]) 요렇게하니 답이나왔다.

다른 사람들이 푼걸 찾아보니 플로이드 와샬? 뭔진 모르겠지만 3중 for문이 좋을거같진 않았다.

22.11.19
프로그래머스 경주로 건설
(0,0) 에서 (n-1, n-1)까지 가는 최단거리를 구하는 문제
직선은 cost 1, 방향이 변하면 cost 5를 준다.
priority_queue를 이용해서 cost값이 젤 작은게 먼저오게 정렬한다음 문제를 풀었다.
같은곳에 방문하더라도 이전 방문때 저장한 값보다 5이상 크지 않다면 방문이 가능하게 했다.
왜냐하면 먼저 방문한 곳이라도 방향이 바뀌면 (방향 전환 5, 직선 1)해서 6의 값을 추가로하지만
늦게 왔더라도 직선상이라면 (최대 4이상 크니까) 4 + 1 하면 5의 값으로 다음 땅을 밟는다.
이런식으로 풀었다.

22.11.20
프로그래머스 입국심사
이분탐색 문제
이분탐색은 구현 했는데 계속 틀렸다.
사람들의 풀이도 찾아봤지만 뭐가틀린지 감이안왔다...
결국 찾은 문제는 count를 int형으로 샜다는것
long long 으로 선언한 뒤 제출하니 끝나버렸다.
변수의 타입을 좀더 신경써야겠다...

22.11.21
프로그래머스 가장 긴 팰린드롬
앞뒤가 똑같은 전화번호같은 문제
첫 번째로는 완전탐색을 통해 팰린드롬을 찾았다.
정확성은 다 맞췄지만 효율성에서 1개가 시간초과가 났다.
다른사람은 어떻게 풀었는지 보니 DP를 활용해서 풀었다.
DP를 생각 안한건 아니지만 점화식을 어떤식으로 새워야하는지 감이 안잡혔었는데 
다른 사람의 풀이를 참고해서 풀었다.

프로그래머스 셔틀버스
게으른 내가 젤 마지막 버스를 타고싶은 문제
크루원들의 도착 시간을 분으로 바꿔 벡터에 저장
첫 버스부터 크루원들을 태운다.
난 마지막 버스가 타고싶으니 마지막 버스가 꽉찼는지 아닌지 확인한다.
마지막 버스에 빈자리가 있으면 마지막 버스가 도착하는 시간에 맞춰서 나간다.
마지막 버스에 빈자리가 없으면 마지막 버스에 가장 늦게 타는 사람보다 1분 먼저 나간다.

22.11.25
프로그래머스 다단계 칫솔 판매
map을 사용해서 풀었다.
각 이름마다 index를 저장하는 map me와
각 이름마다 엄마(자신을 다단계로 끌어들인 사람)가 누군지 저장하는 map parent와
index마다 받을 금액을 저장하는 int 배열 costmap으로 구성
시간복잡도가 최대 n^2이긴하지만 최선인거같기도...

프로그래머스 순위
플로이드 와샬 문제
플로이드 와샬 문제인지 아닌지 생각하는게 어려운거지
실제로 알고리즘을 사용하는게 어려운 문제는 아니였다.

프로그래머스 풍선 터트리기
각 index마다 오른쪽, 왼쪽의 최솟값을 구해서
둘다 작은 경우를 제외하면 결과를 낼 수 있다는걸 찾았다.
int map[1000000][2]을 만들어서 최솟값의 index를 저장해서 풀어보니 시간초과가 나왔다.
아무리 생각해도 이게 최선아닌가 싶어서 다른사람의 풀이를 찾아보니
같은 방식이지만 index가 아니라 값 자체를 저장했다.
나의 풀이의 경우 n^2의 시간이라면 다른사람의 풀이는 n의 시간이 들었다.
문제에 대한 접근의 차이로 시간이 이렇게나 많이 차이가나다니...

프로그래머스 거스름돈
같은 경우를 여러번하는 방법밖에 생각이 안나서 다른사람의 풀이를 참고했다.
dp문제로 dp는 0~100000만원까지 주어진 동전으로 몇가지의 경우가 있는지 나타낸다.
index는 index원이고 값은 경우의 수이다.
이해하면 쉽지만 떠올리는건 쉽지않다.
